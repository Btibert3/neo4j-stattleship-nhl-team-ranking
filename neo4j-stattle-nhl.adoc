= NHL Team Ranking Model using the Stattleship API and Neo4j

:neo4j-version: 2.3.1
:author: Brock Tibert
:twitter: @brocktibert


== Introduction
This post will collect data from Stattleship's sports API using their R package and store the data within
Neo4j in order to rank each NHL team based on their performance through January13 of the 2015-16 NHL season.


== The Data Model

The image below represents the data model that I am going to use for this post.


image::https://raw.githubusercontent.com/Btibert3/neo4j-graphgist-2016/master/stattle-neo-team-datamodel.png[width="400" height="375" alt="NHL Games data model", align="center"]

In short, there are two types of nodes, `Game` and `Team` whereby two teams compete in a game.  There are also 2 types of relationships, which indicate whether or not the team was the `HOME_TEAM` or the `AWAY_TEAM`.  These relationships have properties that indicate how many goals were scored and if the `outcome`, which indicates whether or not that particular team won the game.


=== 1. Install the R package

Assuming that you have R installed, use the commands below to install the required packages for this post.

//hide
[source,r]
----
## factors are the devil
options(stringsAsFactors = FALSE)

# install the required packages in R
install.packages("devtools")
devtools::install_github("stattleship/stattleship-r")
install.packages("dplyr")
install.packages("lubridate")
install.packages("stringr")
devtools::install_github("nicolewhite/RNeo4j")
----


=== 2. Setup the R environment

The code below will load the required packages, set your API token, and create a helper function to parse out the data.

//hide
[source,r]
----
## packages -- if errors, see above
library(stattleshipR)
library(dplyr)
library(lubridate)
library(stringr)
library(RNeo4j)

## set the token - get yours at stattleship.com
set_token("yourtokenhere")

## parse out entries from ss_get_result when walk=T and length > 1
parse_stattle <- function(stattle_list, entry) {
  x <- do.call("rbind", lapply(stattle_list, function(x) x[[entry]]))
  stopifnot(is.data.frame(x))
  return(x)
}
----


=== 3. Get the Data with R

The code below is all you need to get the 2015-16 games.

//hide
[source,r]
----
## get all of the completed games for the 2015-16 season
games_ss <- ss_get_result(ep="games",
                          query=list(status="ended"),
                          walk = TRUE)
----

One note:  The API call is only pulling completed regular season games.


=== 4. Parse out the data into datasets for Neo4j

Below, the code parses out what we need from the API call.


//hide
[source,r]
----
## parse out the games and keep the columns we want (regular season only)
games <- parse_stattle(games_ss, "games") %>%
  filter(interval_type=='regularseason') %>%
  select(id,
         started_at,
         scoreline,
         home_team_id,
         away_team_id,
         winning_team_id,
         attendance,
         duration,
         home_team_score,
         away_team_score,
         score_differential,
         home_team_outcome,
         away_team_outcome)

## parse out the teams from the games API -- need to do that just once
teams <- parse_stattle(games_ss, "home_teams") %>%
  unique %>%
  select(id,
         location,
         name,
         nickname,
         slug)

## extract dateparts from started date
games <- transform(games,
                   start_date = strptime(started_at, "%Y-%m-%dT%H:%M:%S"))
games <- transform(games,
                   year = year(start_date),
                   month = month(start_date),
                   day = day(start_date))

## make the games dataset
games$started_at <- NULL
games$start_date <- NULL

## assumption
write the data to a web-accessible location
----


In the end, we have a `games` and `teams` dataset that we will us to populate our database below.

=== 5. Populate Neo4j

First, set the contraint on the `id` property for teams (which is returned by the API)

//hide
//setup
//output
[source,cypher]
----
CREATE CONSTRAINT ON (n:Team) ASSERT n.id IS UNIQUE;
----

And now import the teams.

//hide
//setup
//output
[source,cypher]
----
// Import the teams
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/Btibert3/neo4j-graphgist-2016/master/data/teams.csv" as row
MERGE (t:Team {id:row.id, nickname:row.nickname, slug:row.slug});
----

Set the game constraints

//hide
//setup
//output
[source,cypher]
----
CREATE CONSTRAINT ON (n:Game) ASSERT n.id IS UNIQUE;
----


and load the games

//hide
//setup
//output
[source,cypher]
----
// Import the games
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/Btibert3/neo4j-graphgist-2016/master/data/games.csv" as row
MERGE (g:Game {id:row.id,
	           duration:toInt(row.duration),
	           attendance:toInt(row.attendance),
	           score_diff:toInt(row.score_differential),
	           scoreline:row.scoreline,
	           year:toInt(row.year),
	           month:toInt(row.month),
	           day:toInt(row.day)});
----

and finally, join the teams and games


//hide
//setup
//output
[source,cypher]
----
// Relate the teams and games
USING PERIODIC COMMIT 10000
LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/Btibert3/neo4j-graphgist-2016/master/data/games.csv" as row
WITH row
MATCH (g:Game {id:row.id})
MATCH (a:Team {id:row.away_team_id})
MATCH (h:Team {id:row.home_team_id})
WITH row, g, a, h
MERGE (a) -[:AWAY_TEAM {goals:toInt(row.away_team_score),
	                    outcome:row.away_team_outcome,
	                    points: CASE WHEN row.away_team_outcome='win' THEN 2
	                                 WHEN row.away_team_outcome='overtime_loss' THEN 1
	                                 ELSE 0
	                             END}]-> (g)
MERGE (h) -[:HOME_TEAM {goals:toInt(row.home_team_score),
	                    outcome:row.home_team_outcome,
	                    points: CASE WHEN row.home_team_outcome='win' THEN 2
	                                 WHEN row.home_team_outcome='overtime_loss' THEN 1
	                                 ELSE 0
	                             END}]-> (g);
----


=== 6. Explore

Let's look at how things are related.

[source,cypher]
----
MATCH (a)-[r]->(b)
WHERE labels(a)<>[] AND labels(b)<>[]
RETURN DISTINCT head(labels(a)) AS This, type(r) AS To, head(labels(b)) AS That
----

//table

And the count of nodes by their label

[source,cypher]
----
MATCH (n)
RETURN labels(n) AS `Node Type`, count(*) AS total
----

//table
